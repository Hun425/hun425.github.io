<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REP-Engine | 채기훈</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/static/pretendard.css" />
</head>
<body>

    <div class="detail-page">
        <nav class="detail-nav">
            <a href="../index.html" class="back-link">&larr; 돌아가기</a>
        </nav>

        <header class="detail-header">
            <div class="detail-header-top">
                <h1>REP-Engine</h1>
                <span class="period">개인 프로젝트</span>
            </div>
            <p class="detail-role">실시간 유저 행동 기반 개인화 추천 엔진</p>
            <div class="tags">
                <span class="tag">Kotlin</span>
                <span class="tag">Kafka</span>
                <span class="tag">Elasticsearch</span>
                <span class="tag">Redis</span>
                <span class="tag">Coroutines</span>
            </div>
        </header>

        <section class="detail-section">
            <h2>프로젝트 개요</h2>
            <p>
                기존 배치 기반 추천 시스템의 한계(실시간성 부족)를 극복하기 위해 설계한 이벤트 기반 실시간 추천 엔진입니다.
                초당 수천 건의 유저 행동 로그를 처리하여 200ms 이내에 개인화된 추천 결과를 제공합니다.
            </p>
        </section>

        <section class="detail-section">
            <h2>아키텍처</h2>
            <div class="image-placeholder">
                <img src="../images/rep-engine-architecture.png" alt="REP-Engine 아키텍처"
                     onerror="this.style.display='none'; this.parentElement.querySelector('.fallback').style.display='block';">
                <p class="fallback" style="display:none;">rep-engine-architecture.png</p>
            </div>
        </section>

        <section class="detail-section">
            <h2>주요 성과</h2>
            <div class="achievement-grid">
                <div class="achievement-card">
                    <span class="achievement-number">&lt; 200ms</span>
                    <p class="achievement-label">추천 응답 시간</p>
                    <p class="achievement-desc">실시간 이벤트 처리 기반<br>즉각적 추천 결과 제공</p>
                </div>
                <div class="achievement-card">
                    <span class="achievement-number">&lt; 5ms</span>
                    <p class="achievement-label">P99 읽기 응답</p>
                    <p class="achievement-desc">Redis 캐시 레이어로<br>안정적 읽기 성능 확보</p>
                </div>
                <div class="achievement-card">
                    <span class="achievement-number">100%</span>
                    <p class="achievement-label">데이터 정합성</p>
                    <p class="achievement-desc">유저별 Mutex Lock으로<br>동시성 문제 해결</p>
                </div>
            </div>
        </section>

        <section class="detail-section">
            <h2>기술적 의사결정</h2>
            <div class="decision-item">
                <h3>Event Pipeline: Kafka + Avro (Schema Registry)</h3>
                <div class="decision-body">
                    <p><strong>배경:</strong> 유저 행동 로그(클릭, 조회, 구매 등)를 실시간으로 수집하고 처리해야 했습니다.</p>
                    <p><strong>선택:</strong> Kafka를 이벤트 버스로 사용하고, Avro + Schema Registry로 스키마 호환성을 관리하여 프로듀서-컨슈머 간 결합도를 낮췄습니다.</p>
                    <p><strong>결과:</strong> 스키마 변경에 유연하게 대응하면서도 안정적인 실시간 데이터 파이프라인을 구축했습니다.</p>
                </div>
            </div>
            <div class="decision-item">
                <h3>Concurrency: Coroutines + Virtual Thread</h3>
                <div class="decision-body">
                    <p><strong>배경:</strong> 추천 결과 생성 시 여러 외부 저장소(Redis, Elasticsearch)에 동시 접근이 필요했습니다.</p>
                    <p><strong>선택:</strong> Kotlin Coroutines로 비동기 처리를 구현하고, Virtual Thread를 도입하여 블로킹 I/O 상황에서도 높은 처리량을 확보했습니다.</p>
                    <p><strong>결과:</strong> 동시 요청 처리 능력이 향상되어, 피크 시간에도 안정적인 응답 속도를 유지합니다.</p>
                </div>
            </div>
            <div class="decision-item">
                <h3>Storage Strategy: Redis + Elasticsearch 하이브리드</h3>
                <div class="decision-body">
                    <p><strong>배경:</strong> 실시간 추천을 위해 빠른 읽기 성능과 벡터 검색 기능이 동시에 필요했습니다.</p>
                    <p><strong>선택:</strong> Hot 데이터와 벡터 캐시는 Redis에, 전체 벡터 검색은 Elasticsearch에 저장하는 하이브리드 전략을 채택했습니다.</p>
                    <p><strong>결과:</strong> 자주 접근하는 데이터는 5ms 이내로 조회하면서, 복잡한 유사도 검색도 지원할 수 있게 되었습니다.</p>
                </div>
            </div>
        </section>

        <section class="detail-section">
            <h2>트러블 슈팅</h2>
            <div class="trouble-shooting">
                <p><strong>Problem:</strong> 실시간 벡터 갱신 시 Lost Update 발생</p>
                <p class="ts-detail">수십만 유저의 행동 로그가 동시에 들어올 때, 취향 벡터 갱신 과정에서 동시성 문제가 발생했습니다. 같은 유저의 이벤트가 동시에 처리되면서 이전 갱신이 덮어씌워지는 Lost Update가 확인되었습니다.</p>
                <p><strong>Solution:</strong> 유저별 Mutex Lock 도입</p>
                <p class="ts-detail">Caffeine 캐시 기반의 Mutex Lock을 적용하여 동일 유저 이벤트를 직렬화했습니다. 읽기 경로는 Redis 캐시를 통해 Lock 없이 처리하여 읽기 성능에는 영향이 없도록 설계했습니다.</p>
                <p class="ts-result"><strong>Result:</strong> 데이터 정합성 100% 보장 및 P99 응답 속도 5ms 미만 달성</p>
            </div>
        </section>

        <footer class="detail-footer">
            <a href="../index.html" class="back-link">&larr; 돌아가기</a>
        </footer>
    </div>
    <!-- GoatCounter -->
    <script data-goatcounter="https://hun425.goatcounter.com/count"
            async src="//gc.zgo.at/count.js"></script>
</body>
</html>
